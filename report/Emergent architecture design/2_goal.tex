\section{GOAL}
We have implemented GAMYGDALA as a plugin in the existing GOAL source code. To do this, we first need to have a good overview of the GOAL architecture.
The GOAL source consists of two major parts: the grammar and the runtime. These parts can be characterized as the parser and interpreter respectively.

\subsection{Grammar overview}
In this section, the parts of the grammar that are relevant to the implementation of our custom action will be covered. \\ 

The grammar uses the antlr4 library to create clear grammar in .g4 files. It then uses this grammar to parse the program. We need to make sure that our custom action (also referred to as plugin) is correctly inserted in the existing grammar. \\ 

The parsing consists of multiple levels. The first level is converting the plain text to collections of very basic expressions. The second level turns these basic expressions into clearer expressions. In this level, every action has its own class, for example. We needed to make sure that such an action exists for each of our custom actions, and that it is created when necessary. \\

All of our custom actions share the same format, that is to say they all take a list of values as their parameters instead of some predicate. Since these actions all share this format, it makes sense to generalise them. This is exactly what we have done. There is an abstract 'parameter action', and to create a new action in the grammar we only need to create a new class for it in a certain package. To allow for easy class loading, the reflections package was used.

The classes that handle the second level of parsing are called validators, because they not only parse the program but also make sure that everything is correct. The grammar has four different validators for the four parts of the goal language: agents, multi-agent systems, modules and tests. Most relevant for us are the agents; we need to make sure that our custom action passes the validation of the agent's execution code, and also that the parameters that are passed to the action are preserved in the process. \\ 

The grammar is not responsible for any communication with the actual implementation of the plugin; it just makes sure that an action is created, and the parameters, though not yet interpreted, are passed to it.

\subsection{Runtime overview}
In this section, the parts of the runtime that are relevant to the implementation of our custom action will be covered. In the runtime changes were made to allow for interpretation of the custom actions, and the actual interpretation is hooked to the interface between GOAL and GAMYGDALA. \\ 

The runtime traverses the rules of the agent program, and when it crosses an action, it creates an action executor for said action. This action executor is then executed. We needed to make sure that such an action executor exists for each of our custom actions. \\

Since all actions still share the same format, generalisation could also be applied  in the runtime. We created an abstract 'parameter action executor', which all specific action executor implementations extended. Each action executor specifies for which action it is an executor.

All these action executors are put together in the same package. That way, the runtime can easily find the action executor that matches that action is has come across, again using the reflections package.

Then, in this action executor, the call is forwarded towards the GOAL-GAMYGDALA. Since this interface is built so that GOAL does not have to know anything at all about GAMYGDALA except for the actions it provides, the raw terms are passed to the interface.