\section{Reflection from a software engineering perspective}
To streamline the process of developing and to ensure product quality, it is necessary to adhere to software engineering guidelines and principles. This section will discuss the measures that have been taken from a software engineering perspective and in which way they have affected the final product and the development process.


% Reflection on the product and process from a software engineering perspective
\subsection{Product}
From the first day on it was clear there was a challenging task to solve: porting an existing code base, the emotion engine GAMYGDALA, from JavaScript to Java. While ''JavaScript'' and ''Java'' sound very similar, these are actually two very different languages and require a very different approach from a programming perspective. Java is an object-oriented language pur sang, while JavaScript, in practice, uses a more procedural programming style.

Because Joost Broekens, the original author of the JavaScript version of GAMYGDALA, has programmed GAMYGDALA using a semi-object oriented approach, we initially decided to port the classes and methods to Java one on one. The Java port was therefore immediately feature complete. However, from a software engineering perspective, the code lacked proper design patterns and thus overall quality due to the fact that JavaScript simply does not support such  programming structures. Using code quality assessment tool InCode Helium \citep{incode}, we identified major flaws in the code and started a large-scale refactoring process to incorporate proper software design principles. During this process, we have reduced or split up very large methods, refactored methods with redundant or duplicate code and have implemented design patterns\footnote{For an overview of all design patterns that have been used, please review the Emergent Architecture Design \citep{ead}.} where appropriate. The code review by Software Improvement Group \citep{SIG} identified additional flaws, which have been corrected in the final product.

The next and final challenge to face has been the creation of a GOAL \citep{goal} plug-in for GAMYGDALA. The plug-in acts as an interface for the GAMYGDALA Java port, allowing other GOAL programs to utilize the emotion engine.

TODO(Wouter): Stuk over relations in GOAL.

Creating the new GAMYGDALA actions within the GOAL source code proved to be rather difficult. Though we had been able to create our new actions, the way that we had done this seemed quite dirty. GOAL was not particularly ready for the addition of new actions and we had to violate the open/closed principle a lot to make sure that our new actions were recognized and used. To make sure that this would no longer be the case, at least for our own project, we created classloaders that would automatically recognize any new actions when we would add them.

We have tested our implementation, the Java port as well as the GOAL plug-in, thoroughly. We have made use of JUnit, a Java unit testing framework \citep{junit}, to run unit tests which are developed for the better part of the code. The current line coverage, a metric to measure how much of the code is called in unit tests, is currently at 90\%. Additionally, a test suite written in JavaScript was available for the original version of GAMYGDALA. To be able to use these tests in Java, part of the JavaScript code was altered and a Java interface for this test suite has been developed. The Java class to interface with the test suite utilizes a JavaScript engine, Nashorn, included with Java 8. Nashorn is the de-facto JavaScript engine for Java and provides high-performance \citep{projnashorn} and full ECMAScript 5.1 compliance. Alterations made to the GAMYGDALA JavaScript test suite include:
\begin{itemize}
\item Adapting the GAMYGDALA object instantiation to the new implementation of the Java port to be able to use it in the first place.
\item Replacing JavaScript arrays with Java ArrayLists (a technique which is made possible by Nashorn, see: \href{http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/prog_guide/javascript.html#A1147187}{documentation}), to be able to use these objects as arguments in method calls.
\end{itemize}
The Java test class, which runs the JavaScript test suite, instantiates a new Nashorn JavaScript engine object which loads the test suite framework and subsequently runs the tests in the suite. The test suite returns a string which is then parsed in a JUnit test to allow its usage in the existing unit test workflow.

\subsection{Process}
To streamline the development process, we have used an iterative, incremental and agile approach: SCRUM \citep{scrum}. Every week, we have determined which tasks we would like to have completed which of these tasks have to highest priority. The selected tasks for that ``sprint" (a one week period in which the selected tasks are to be completed) are then, roughly equally, divided amongst team members. At the end of the sprint, an evaluation takes place and the plan for the next sprint is determined. If we were unable to complete a particular task, it is added to the sprint plan for the next week.

To make collaborating easier, we have used GitHub \citep{gh} to host our code. We have used multiple repositories for different parts of the project. The GAMYGDALA port, GOAL plug-in and reports all used a different repository. This enabled us to work seamlessly together at different parts of the final product. Furthermore, we have utilized GitHub using a pull-based development approach. This means that whenever a team member finished and tested a piece of code on a separate branch, a pull request has to be created. Another team member has to review the code and check it for possible errors, before the request can be merged in the master branch. Two sets of eyes on a particular piece of code increases the likelihood of finding bugs before they make their way into the final product. 

To ensure code quality, we have used continuous integration. Each time a team member has created new software functionality, he must also provide unit tests for that particular functionality. For each commit to the repository, TravisCI \citep{travis}, a continuous integration tool, runs all the unit tests and generates a test report, to make sure no existing functionality breaks. Also, Checkstyle is automatically executed to make sure the code formatting adheres to guidelines we have established at the beginning of the project. These measures aid other team members in determining the quality of a commit and whether or not a pull request can be merged.