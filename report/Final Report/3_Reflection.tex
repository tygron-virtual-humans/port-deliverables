\section{Reflection from a software engineering perspective}
There are unlimited ways to approach the development of a software program. To streamline the process of developing and to ensure product quality, it is necessary to adhere to software engineering guidelines and principles. This section will discuss the measures that have been taken from a software engineering perspective and in which way they have affected the final product and the development process.


% Reflection on the product and process from a software engineering perspective
\subsection{Product}
From the first day on it was clear there was a challenging task to solve: porting an existing code base, the emotion engine GAMYGDALA, from JavaScript to Java. While ''JavaScript'' and ''Java'' sound very similar, these are actually two very different languages and require a very different approach from a programming perspective. Java is an object-oriented language pur sang, while JavaScript, in practice, uses a more procedural programming style.

Because Joost Broekens, the original author of the JavaScript version of GAMYGDALA, has programmed GAMYGDALA using a semi-object oriented approach, we initially decided to port the classes and methods to Java one on one. The Java port was therefore immediately feature complete. However, from a software engineering perspective, the code lacked proper design patterns and thus overall quality due to the fact that JavaScript simply does not support such  programming structures. Using code quality assessment tool InCode Helium (\textbf{TODO: REF}), we identified major flaws in the code and started a large-scale refactoring process to incorporate proper software design principles. During this process, we have reduced or split up very large methods, refactored methods with redundant or duplicate code and have implemented design patterns\footnote{For an overview of all design patterns that have been used, please review the Emergent Architecture Design \citep{ead}.} where appropriate. The code review by Software Improvement Group identified additional flaws, which have been corrected in the final product.

The next and final challenge to face has been the creation of a GOAL \citep{goal} plug-in for GAMYGDALA. The plug-in acts as an interface for the GAMYGDALA Java port, allowing other GOAL programs to utilize the emotion engine.

Again, we were dealing with multiple types of language structures. GAMYGDALA is very structural, primarily based on one thread, since it's made for simple games. In GOAL, however, every agent runs in a different thread at the same time, and with that also past each other sometimes. For example, sometimes agents would create relations to other agents that were not running. We have had to make some sort of relation queue so that these relations were only processed once the target agent became active.

Though we were able to solve this problem, there is another problem that remains largely unsolved because it would require significant changes in GAMYGDALA itself. This problem is the fact that GAMYGDALA primarily assumes that every agent is omniscient, while in GOAL each agent thinks and perceives for itself and therefore their beliefs about certain events may differ. Agents are able to appraise events for themselves, luckily, so we do get most of the GAMYGDALA functionality. Relations, however, do not work optimal. For example, if one agent would appraise that it has done something that is positive for itself and negative for another agent, this other agent would feel all kinds of negative emotions. However, when these two things are separated into the first agent appraising the positive side, and the second agent appraising the negative side, these negative emotions aren't nearly as intense. This is because the face that the other agent gets happy is also supposed to create negative emotions, but in this way it does not. If we were to do this anyway, we would be conflicting the GOAL philosophy.

All these compatibility problems aside, actually working in the GOAL source code was another big challenge. GOAL is not one of the best documented pieces of software and it proved to be quite some effort to understand the source enough so that we could start tinkering with it. It took a while to understand even the project structure, since there were lots of different maven projects depending on each other, but we managed after a long time of tinkering with the pomfiles and fixing errors, we got it to work. Through communication with Vincent Koenen and Koen Hindriks, both major collaborators on the GOAL project, we have been able to gain a good understanding of the source code. With our newfound understanding, we were able to create the new actions.

Though we had been able to create our new actions, the way that we had done this seemed rather dirty. GOAL was not particularly ready for the addition of new actions and we had to violate the open/closed principle a lot to make sure that our new actions were recognized and used. To make sure that this would no longer be the case, at least for our own project, we created classloaders that would automatically recognize any new actions when we would add them.

Because of these types of issues, working with GOAL was a very useful experience. It has taught us about the difficulties of working with someone else's code. We have seen cases of beautifully engineered code that we have learnt from, as well as cases where the implementation lacked adherence to important design principles. By having been the people who had to add new code to someone else's code, we will be able to write better code for someone else to use in turn. Also, we have been able to learn how to adhere to most design principles, even if you are modifying code that does not, which is a rather difficult task.

We have tested our implementation, the Java port as well as the GOAL plug-in, thoroughly. For the GAMYGDALA port, a test suite written in JavaScript was available. In order to be able to execute these tests in a Java environment, we have adapted part of the JavaScript code and have written an interface for this test suite in Java. The result is then interpreted in a JUnit test to be able to use this in continuous testing.

\subsection*{TODO}
\begin{itemize}
\item Stuk over GOAL
\item Stuk over testing (en JS testing enzo)
\end{itemize}

\subsection{Process}
To streamline the development process, we have used an iterative, incremental and agile approach: SCRUM. Every week, we've determined which tasks we would like to have completed which of these tasks have to highest priority. The selected tasks for that ''sprint'' (a one week period in which the selected tasks are to be completed) are then, roughly equally, divided amongst team members. At the end of the sprint, an evaluation takes place and the plan for the next sprint is determined. If we were unable to complete a particular task, it is added to the sprint plan for the next week.

TODO: Meer over sprint.

To make collaborating easier, we have used GitHub to host our code. We have used multiple repositories for different parts of the project. The GAMYGDALA port, GOAL plug-in and reports all used a different repository. This enabled us to work seamlessly together at different parts of the final product. Furthermore, we've utilized GitHub using a pull-based development approach. This means that whenever a team member finished and tested a piece of code on a separate branch, a pull request has to be created. Another team member has to review the code and check it for possible errors, before the request can be merged in the master branch. Two sets of eyes on a particular piece of code increases the likelihood of finding bugs before they make their way into the final product. 

To ensure code quality, we have used continuous integration. Each time a team member has created new software functionality, he must also provide unit tests for that particular functionality. For each commit to the repository, Travis, a continuous integration tool, runs all the unit tests and generates a test report, to make sure no existing functionality breaks. Also, Checkstyle is automatically executed to make sure the code formatting adheres to guidelines we've established at the beginning of the project. These measures aid other team members in determining the quality of a commit and whether or not a pull request can be merged.