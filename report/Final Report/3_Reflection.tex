\section{Reflection from a software engineering perspective}
There are unlimited ways to approach the development of a software program. To streamline the process of developing and to ensure product quality, it is necessary to adhere to software engineering guidelines and principles. This section will discuss the measures that have been taken from a software engineering perspective and in which way they have affected the final product and the development process.


% Reflection on the product and process from a software engineering perspective
\subsection{Product}
From the first day on it was clear there was a challenging task to solve: porting an existing code base, the emotion engine GAMYGDALA, from JavaScript to Java. While ''JavaScript'' and ''Java'' sound very similar, these are actually two very different languages and require a very different approach from a programming perspective. Java is an object-oriented language pur sang, JavaScript, in practice, uses a more procedural programming style.

Because Joost Broekens, the original author of the JavaScript version of GAMYGDALA, has programmed GAMYGDALA using a semi-object oriented approach, we initially decided to port the classes and methods to Java one on one. The Java port was therefore immediately feature complete. However, from a software engineering perspective, the code lacked proper design patterns and thus overall quality due to the fact that JavaScript simply does not support such  programming structures. Using code quality assessment tool InCode Helium (\textbf{TODO: REF}), we identified major flaws in the code and started a large-scale refactoring process to incorporate proper software design principles. During this process, we have reduced or split up very large methods, refactored methods with redundant or duplicate code and have implemented design patterns\footnote{For an overview of all design patterns that have been used, please review the Emergent Architecture Design \citep{ead}.} where appropriate. The code review by Software Improvement Group identified additional flaws, which have been corrected in the final product.

The next and final challenge to face has been the creation of a GOAL \citep{goal} plug-in for GAMYGDALA. The plug-in acts as an interface for the GAMYGDALA Java port, allowing other GOAL programs to utilize the emotion engine.

We have tested our implementation, the Java port as well as the GOAL plug-in, thoroughly. For the GAMYGDALA port, a test suite written in JavaScript was available. In order to be able to execute these tests in a Java environment, we have adapted part of the JavaScript code and have written an interface for this test suite in Java. The result is then interpreted in a JUnit test to be able to use this in continuous testing.

\subsection*{TODO}
\begin{itemize}
\item Stuk over GOAL
\item Stuk over testing (en JS testing enzo)
\end{itemize}

\subsection{Process}
To streamline the development process, we have used an iterative, incremental and agile approach: SCRUM. Every week, we've determined which tasks we would like to have completed which of these tasks have to highest priority. The selected tasks for that ''sprint'' (a one week period in which the selected tasks are to be completed) are then, roughly equally, divided amongst team members. At the end of the sprint, an evaluation takes place and the plan for the next sprint is determined. If we were unable to complete a particular task, it is added to the sprint plan for the next week.

TODO: Meer over sprint.

To make collaborating easier, we have used GitHub to host our code. We have used multiple repositories for different parts of the project. The GAMYGDALA port, GOAL plug-in and reports all used a different repository. This enabled us to work seamlessly together at different parts of the final product. Furthermore, we've utilized GitHub using a pull-based development approach. This means that whenever a team member finished and tested a piece of code on a separate branch, a pull request has to be created. Another team member has to review the code and check it for possible errors, before the request can be merged in the master branch. Two sets of eyes on a particular piece of code increases the likelihood of finding bugs before they make their way into the final product. 

To ensure code quality, we have used continuous integration. Each time a team member has created new software functionality, he must also provide unit tests for that particular functionality. For each commit to the repository, Travis, a continuous integration tool, runs all the unit tests and generates a test report, to make sure no existing functionality breaks. Also, Checkstyle is automatically executed to make sure the code formatting adheres to guidelines we've established at the beginning of the project. These measures aid other team members in determining the quality of a commit and whether or not a pull request can be merged.