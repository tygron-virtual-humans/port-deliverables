\section{Reflection from a software engineering perspective}
To streamline the process of developing and to ensure product quality, it is necessary to adhere to software engineering guidelines and principles. This section will discuss the measures that have been taken from a software engineering perspective and in which way they have affected the final product and the development process.


% Reflection on the product and process from a software engineering perspective
\subsection{Product}
From the first day on it was clear there was a challenging task to solve: porting an existing code base, the emotion engine GAMYGDALA, from JavaScript to Java. While ''JavaScript'' and ''Java'' sound very similar, these are actually two very different languages and require a very different approach from a programming perspective. Java is an object-oriented language pur sang, while JavaScript, in practice, uses a more procedural programming style.

Because Joost Broekens, the original author of the JavaScript version of GAMYGDALA, has programmed GAMYGDALA using a semi-object oriented approach, we initially decided to port the classes and methods to Java one on one. The Java port was therefore immediately feature complete. However, from a software engineering perspective, the code lacked proper design patterns and thus overall quality due to the fact that JavaScript simply does not support such  programming structures. Using code quality assessment tool InCode Helium \citep{incode}, we identified major flaws in the code and started a large-scale refactoring process to incorporate proper software design principles. During this process, we have reduced or split up very large methods, refactored methods with redundant or duplicate code and have implemented design patterns\footnote{For an overview of all design patterns that have been used, please review the Emergent Architecture Design \citep{ead}.} where appropriate. The code review by Software Improvement Group \citep{SIG} identified additional flaws, which have been corrected in the final product.

The next and final challenge to face has been the creation of a GOAL \citep{goal} plug-in for GAMYGDALA. The plug-in acts as an interface for the GAMYGDALA Java port, allowing other GOAL programs to utilize the emotion engine.

Creating the new GAMYGDALA actions within the GOAL source code proved to be rather difficult. Though we had been able to create our new actions, the way that we had done this seemed quite dirty. GOAL was not particularly ready for the addition of new actions and we had to violate the open/closed principle to make sure that our new actions were recognized and used. To make sure that this would no longer be the case, at least for this project, factories that incorporate classloaders were created, so that any new actions would instantly be recognized after they were added.

Another difficulty has been the relation management. GOAL is not a very linear language; multiple agents act in multiple threads, and they might not be active at the same time. Because of this, agents might be creating relations to other agents that are not currently active. If this call would be forwarded directly to GAMYGDALA, it would simply say that the other agent does not exist and then do nothing. To fix this, a relation will simply be saved in the GOAL-GAMYGDALA interface if its target does not yet exist. Then, when the target becomes active, the relation is autmatically applied.

The implementation of the Java port as well as the GOAL plug-in is thoroughly tested. JUnit, a Java unit testing framework \citep{junit}, was used to run unit tests which are developed for the better part of the code. The current line coverage, a metric to measure how much of the code is called in unit tests, is currently at 90\%. Additionally, a test suite written in JavaScript was available for the original version of GAMYGDALA. To be able to use these tests in Java, part of the JavaScript code was altered and a Java interface for this test suite has been developed. The Java class to interface with the test suite utilizes a JavaScript engine, Nashorn, included with Java 8. Nashorn is the de-facto JavaScript engine for Java and provides high-performance \citep{projnashorn} and full ECMAScript 5.1 compliance. Alterations made to the GAMYGDALA JavaScript test suite include:
\begin{itemize}
\item Adapting the GAMYGDALA object instantiation to the new implementation of the Java port to be able to actually use it.
\item Replacing JavaScript arrays with Java ArrayLists (a technique which is made possible by Nashorn, see: \href{http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/prog_guide/javascript.html#A1147187}{manual}), to be able to use these objects as arguments in method calls.
\end{itemize}
The Java test class, which runs the JavaScript test suite, instantiates a new Nashorn JavaScript engine object which loads the test suite framework and subsequently runs all tests. The test suite returns a result string which is then parsed in a JUnit test to allow its usage in the existing unit test workflow.

\subsection{Process}
To streamline the development process, an iterative, incremental and agile approach was used: SCRUM \citep{scrum}. Each week, the tasks which had to be completed were determined and ordered based on priority. Then, the most important tasks were selected for the \textit{sprint} (a one week period in which the selected tasks are to be completed) and equally divided amongst the team members. At the end of the sprint, an evaluation takes place and the plan for the next sprint is determined. If a task has not been completed within the sprint window, it is added to the sprint plan for the next week.

To make collaborating easier, we have used GitHub \citep{gh} to host our code. We have used multiple repositories for different parts of the project. The GAMYGDALA port, GOAL plug-in and reports all used a different repository. This enabled us to work seamlessly together at different parts of the final product. Furthermore, we have utilized GitHub using a pull-based development approach. This means that whenever a team member finished and tested a piece of code on a separate branch, a pull request has to be created. Another team member has to review the code and check it for possible errors, before the request can be merged in the master branch. Two sets of eyes on a particular piece of code increases the likelihood of finding bugs before they make their way into the final product. 

Continuous integration has been used to ensure code quality. Each time a team member created new software functionality, unit tests were also to be provided for that particular functionality. For each commit to the repository, TravisCI \citep{travis}, a continuous integration tool, runs all the unit tests and reports back with the test result. This workflow ensures no existing functionality breaks when new code is developed. Additionally, Checkstyle, a code style checker, is automatically executed to make sure the code formatting adheres to guidelines that have been established at the beginning of the project. These measures aid other team members in determining the quality of a code commit and whether or not a pull request can be safely merged.